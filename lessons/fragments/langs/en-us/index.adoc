= Fragments for DS

== Question Types @duration{10 minutes}

=== Overview
Students begin to categorize questions, sorting them into "lookup", "compute", and "relate" questions - as well as questions that simply can't be answered based on the data.

=== Launch
Once we have a dataset, we can start asking questions! But how do we know what questions to ask? There’s an art to asking the right questions, and good Data Scientists think hard about what kind of questions can and can’t be answered.

Most questions can be broken down into one of four categories:

- *Lookup questions* -- These can be answered simply by looking up a single value in the table and reading it out. Once you find the value, you’re done! Examples of lookup questions might be “is Sunflower fixed?” or “How many legs does Felix have?”

- *Compute questions* -- These can be answered by computing an answer across a single column. Examples of computing questions might be “how much does the heaviest animal weigh?” or “What is the average age of animals from the shelter?”

- *Relate questions* -- These ones take the most work, because they require looking for relationships between multiple columns. Examples of analysis questions might be “Do cats tend to be adopted faster than dogs?” or “Are older animals heavier than young ones?”

- *Can't answer* -- These are questions that just can't be answered based on the available data. We might ask "are cats or dogs better for elderly owners?", but the Animals Dataset doesn't have information that we can use to answer it.

=== Investigate
[.lesson-instruction]
- Come up with examples for each type of question.
- Look back at the Wonders you wrote on
  @printable-exercise{ds-intro/pages/questions-and-column-descriptions.adoc}. Are any of these Lookup, Compute, or Relate questions? Circle the question type that’s appropriate. Can you come up with additional examples for each type of question?

=== Synthesize
Have students share their questions with the class. Allow time for discussion!

Have students reflect on what they learned by writing on @printable-exercise{pages/whats-on-your-mind.adoc}. Some prompts that may be helpful:

* What new vocabulary did you learn?
* What question was exciting to you, and what data would you need to answer it? Is that data Categorical or Quantitative?
* What do you hope to learn in the next lesson?

== Additional Exercises:

- @opt-printable-exercise{pages/what-can-you-answer.adoc}

=== Overview
Students learn how to define values in Pyret (note that these definitions work the way variable substitution does in math, as opposed to variable assignment you may have seen in other programming languages).

=== Launch
Pyret allows us to define names for values using the `=` sign. In math, you’re probably used to seeing definitions like _x = 4_, which defines the name x to be the value 4. Pyret works the same way, and you’ve already seen two names defined in this file: `shelter-sheet` and `animals-table`. We generally write definitions on the left, in the Definitions Area. You can add your own definitions, for example:

  my-name = "Maya"
  sum = 2 + 2
  kittens-are-cute = true

[.lesson-instruction]
--
With your partner, take turns adding definitions to this file:

- Define a value with name `food`, whose value is a String representing your favorite food
- Define a value with name `year`, whose value is a Number representing the current year
- Define a value with name `likes-cats`, whose value is a Boolean that is `true` if you like cats and `false` if you don’t
--

=== Synthesize
Why is it useful to be able to define values, and refer to them by name?

-------


Or a function called `nametag` that consumes a _Row_ from the animals table, and draws that animal's name in purple letters.
----
fun nametag(r):
  text(r["name"], 10, "purple")
end
----

*NOTE:* for now, students will follow the pattern for row-consuming functions, so that both examples include a lookup operation. Eventually, however, students will write examples that do *not* contain lookups.

---

* create custom scatter plots, using functions they have defined

== Custom Scatter Plot Images @duration{15 minutes}

=== Overview
Students discover _functions that consume other functions_, and compose a scatter plot function with one of the functions they've already defined.

=== Launch
Students have used Pyret functions that use Numbers, Strings, Images, and even Tables and Rows. Now they've written functions of their own that work with these data types. However, Pyret functions can even use _other functions_! Have students look at the Contract for `image-scatter-plot`:
----
 image-scatter-plot :: (t :: Table, xs :: String, ys :: String, f :: (Row -> Image)) -> Image
----
This function looks a lot like the regular `scatter-plot` function. It takes in a table, and the names of columns to use for x- and y-values. Take a closer look at the third input...
----
...f :: (Row -> Image)...
----
_That looks like the contract for a function!_ Indeed, the third input to `image-scatter-plot` is named `f`, which itself is a function that consumes Rows and produces Images. In fact, students have just defined a function that does exactly that!

=== Investigate
[.lesson-instruction]
- Type `image-scatter-plot(animals-table, "pounds", "weeks", nametag)` into the Interactions Area.
- What did you get?
- What other scatter plots could we create?

@ifpathway{data-science}{
*Note:* the optional lesson @link{../if-expressions/, If Expressions} goes deeper into basic programming constructs, using `image-scatter-plot` to motivate more complex (and exciting!) plots.
}

FRAGMENT FOR MATH

[.lesson-point]
For each input to a function, there is exactly one output.

@span{.right}{ @image{images/VerticalLineTest.png, "Source: Wikipedia", 250} }
Functions are a lot like machines: values go in, something happens, and new values come out. Let's start with an example of a function we all know: adding two numbers! Addition is like a machine that takes in pairs of numbers and produces a sum.

Whenever we use any machine, we always think about what goes in and what comes out. A coffee maker takes in coffee beans and water, and produces coffee. A toaster takes in bread and produces toast. We don't have to know exactly how coffee makers or toasters work in order to _use_ them. All we need to know is what type of thing goes in and what type of thing should come out!

In our coffee-maker example, we expect to get the exact same coffee out if we use the exact same beans and water each time. If you put bread in a toaster and got a bagel out, you'd be pretty surprised! __Functions work the same way:__  no matter how many times you plug in the same number, you will _always_ get the same result. And if you don't? *It's not a function!*

Consider the graphs on the right: for every input on the x-axis, a function will produce a _single_ output. If we draw a vertical line and it hits the graph more than once, it means there is __more than one output__ for the same input. Like any good machine, function machines must be *reliable*.

=== Investigate

We use something called a @vocab{Contract} to keep track of what goes in and out of these machines called functions. Contracts are like a "cheat sheet" for using functions. Once you know how to read one, you can quickly figure out how to use a function just by looking at its contract!
