= Fragments for DS

== Introducing Datasets in Pyret @duration{10 minutes}

=== Overview
Students open up the Pyret environment (code.pyret.org, or "CPO") and see how tables look in Pyret.

==== Launch
The first few lines in the Definitions Area tell Pyret to `import` files from elsewhere, which contain tools we’ll want to use for this course. We’re importing a file called Bootstrap:Data Science, as well as files for working with Google Sheets, tables, and images:

  include shared-gdrive("Bootstrap-DataScience-...")
  include gdrive-sheets
  include tables
  include image

After that, we see a line of code that _defines_ `shelter-sheet` to be a spreadsheet. This table is loaded from Google Drive, so now Pyret can see the same spreadsheet you do. (Notice the funny scramble of letters and numbers in that line of code? If you open up the Google Sheet, you'll find that same scramble in the address bar! That scramble is how the Pyret editor knows which spreadsheet to load.) After that, we see the following code:

  # load the 'pets' sheet as a table called animals-table
  animals-table = load-table: name, species, age, fixed, legs
    source: pets-sheet.sheet-by-name("pets", true)
  end

The first line (starting with `#`) is called a _Comment_. Comments are notes for humans, which the computer ignores. The next line defines a new table called `animals-table`, which is loaded from the `shelter-sheet` defined above. We also create names for the columns: `name`, `species`, `sex`, `age`, `fixed`, `legs`, `pounds` and `weeks`. We could use any names we want for these columns, but it’s always a good idea to pick names that make sense!

[.lesson-point]
Even if your spreadsheet already has column headers, Pyret requires that you name them in the program itself.

[.lesson-instruction]
Click “Run”, and type `animals-table` into the Interactions Area to see what the table looks like in Pyret. Is it the same table you saw in Google Sheets? What is the same? What is different?

In Data Science, every table is composed of cells, which are arranged in a grid of rows and columns. Most of the cells contain data, but _the first row and first column_ are special. The first row is called the @vocab{header row}, which gives a unique name to each variable (or “column”) in the table. The first column in the table is the @vocab{identifier column}, which contains a unique ID for each row. Often, this will be the name of each individual in the table, or sometimes just an ID number.

Below is an example of a table with one header row and two data rows:

[.pyret-table,cols="5a,5a,5a,5a,5a,5a,5a,5a",options="header"]
|===
| name | species | sex | age | fixed | legs | pounds | weeks
| "Sasha" | "cat" | "female" | 1 | false | 4 | 6.5 | 3
| "Mittens" | "cat" | "female" | 2 | true | 4 | 7.4 | 1
|===

=== Investigate
[.lesson-instruction]
- How many variables are listed in the header row for the Animals Dataset? What are they called? What is being used for the identifier column in this dataset?
- Try changing the name of one of the columns, and click "Run". What happens when you print out the table back in the Interactions Area?
- What happens if you remove a column from the list? Or add an extra one?


After the header, Pyret tables can have any number of @vocab{data rows}.
Each data row has values for every column variable (nothing can be left empty!). A table can have any number of data rows, including _zero_, as in the table below:

[.pyret-table,cols="5a,5a,5a,5a,5a,5a,5a,5a",options="header"]
|===
| name | species | sex | age | fixed | legs | pounds | weeks
|===

Pyret lets us use many different kinds of data. In the animals table, for example, there are Numbers (the number of legs each animal has), Strings (the species of the animal), and Booleans (whether it is true or false that an animal is fixed). Pyret has the usual arithmetic operators: addition (`+`), subtraction (`-`), multiplication (`*`), and division (`/`).

To identify if an animal is male, we need to know if the value in the `sex` column is _equal_ to the string `"male"`. To sort the table by age, we need to know if one animal’s age is _less than_ another’s and should come before it. To filter the table to show only young animals, we might want to know if an animal’s age is _less than_ 2. Pyret has Boolean operators, too: equals (`==`), less-than (`<`), greater-than (`>`), as well as greater-than-or-equal (`>=`) and less-than-or-equal (`<=`).

Additional Exercises - 
- @opt-printable-exercise{pages/boolean-operators.html, Boolean Operators}


FRAGMENT FOR MATH

[.lesson-point]
For each input to a function, there is exactly one output.

@span{.right}{ @image{images/VerticalLineTest.png, "Source: Wikipedia", 250} }
Functions are a lot like machines: values go in, something happens, and new values come out. Let's start with an example of a function we all know: adding two numbers! Addition is like a machine that takes in pairs of numbers and produces a sum. 

Whenever we use any machine, we always think about what goes in and what comes out. A coffee maker takes in coffee beans and water, and produces coffee. A toaster takes in bread and produces toast. We don't have to know exactly how coffee makers or toasters work in order to _use_ them. All we need to know is what type of thing goes in and what type of thing should come out!

In our coffee-maker example, we expect to get the exact same coffee out if we use the exact same beans and water each time. If you put bread in a toaster and got a bagel out, you'd be pretty surprised! __Functions work the same way:__  no matter how many times you plug in the same number, you will _always_ get the same result. And if you don't? *It's not a function!*

Consider the graphs on the right: for every input on the x-axis, a function will produce a _single_ output. If we draw a vertical line and it hits the graph more than once, it means there is __more than one output__ for the same input. Like any good machine, function machines must be *reliable*. 

=== Investigate

We use something called a @vocab{Contract} to keep track of what goes in and out of these machines called functions. Contracts are like a "cheat sheet" for using functions. Once you know how to read one, you can quickly figure out how to use a function just by looking at its contract!
