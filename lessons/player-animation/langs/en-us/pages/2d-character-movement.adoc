= Character Movement in Two Dimensions

[.center]
@ifproglang{wescheme}{
@show{
  (contract "update-danger" '("Number") "Number"
	"takes in danger's x-coordinate and produces the next one")
}
}
@ifproglang{pyret}{
@show{
  (contract "update-danger" '("Number" "Number") "Number"
	"takes in danger's x and y-coordinates and produces the next x-coordinate")
}
}

The `update-danger` function only moves our `DANGER` left or right... because it doesn't do anything with the y-coordinate!

Suppose we wanted to write a new function, `update-danger-2` that moves the `DANGER` _diagonally_...

@vspace{1ex}

@ifproglang{wescheme}{
@n What will have to change about the Domain? @fitb{}{@ifsoln{It will need two Numbers!}}
}


@ifproglang{pyret}{
@n What is the `update danger` function doing with the second input? @fitb{}{@ifsoln{Nothing! It takes in the y-coordinate, but ignores it.}}
}

@n What, if anything, will have to change about the Range? @fitb{}{@ifsoln{It will need a second Number.}}

@vspace{1ex}
Since an (x, y) coordinate has two Numbers, one idea might be to write the contract this way:

[.center]
@show{
  (contract "update-danger-2" '("Number Number") "Number Number"
	"take in danger's x- and y-coordinate, and produces the next x- and next y-coordinate")
}

...But that contract breaks an important rule about functions: **Given an input, _all functions must produce one output!_** We need some way to package two Numbers together into a single value.

@vspace{1ex}

Fortunately, our programming language has another data type, called a Posn, which utilizes two Numbers to describe a single "position"! We can make a Posn to represent the position (100, 200) with the following code: @show{ (code '(make-posn 100 200)) }

@n What expression will make a Posn representing the origin? @fitb{}{@showsoln{(code '(make-posn 0 0))}}

@n Write the contract for the @show{(code 'make-posn)} function on the line below.

@fitb{}{@showsoln{(contract "make-posn" '("Number Number") "Posn")}}

@vspace{1ex}

@design-recipe-exercise{"update-danger-2"
"On the lines below, write the new contract and purpose for @funname, so that it produces a Posn instead of a Number. Then complete the Design Recipe."
#:headless? #t
#:domain-list '(Number Number)
#:range "posn"
#:purpose "Consumes an x and y coordinate, adds 50 to each to move the character along a diagonal, and returns a new posn"
#:show-purpose? #f
#:num-examples 2
#:example-list '((0 10 (make-posn (+ 0 50) (+ 10 50)))
                 (20 25 (make-posn (+ 20 50) (+ 25 50))))
#:show-examples '((#f #f #f) (#f #f #f #f))
#:param-list '(x y)
#:show-params? #f
#:body '(make-posn (+ x 50) (+ y 50) )
#:show-body? #f
#:grid-lines? #t
}

@vspace{1ex}

*Add your new function (including contract, purpose, examples, and definition) to your game file and change `update-danger` to `update-danger-2` in the list at the very end of the file to make your `DANGER` and `TARGET` move in two dimensions!*
