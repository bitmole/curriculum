= Method Chaining

@lesson-description{Students continue practicing the Design
Recipe, and learn how to build and transform columns in a table.
They also learn how to chain methods together, and define more
sophisticated subsets. }

[@lesson-intro-table]
|===
@prereqs-stds{}
|Product Outcomes
|Students define functions that sort, filter, or extend the
animals table

@worksheet-include{ds-question-types/xtra/lang-prereq.adoc}
|===

== Review (Time 15 minutes)

Take a minute to look back at the opening questions you saw at
the beginning of the class, and choose another one that interests
you.

[.lesson-instruction]
Using what you know now, what information would you need to
collect in order to answer it? What subsets would you need to
create? What analysis would you need to perform?

////
Debrief as a class.
////

[.lesson-instruction]
- What kinds of displays and charts have you learned about so far?
- What does each kind of display tell us about a dataset?
- When would you use each kind of display?

////
Spend some time on this -- let students discuss amongst themselves, and facilitate as necessary.
////

== Chaining Methods (Time 30 minutes)
Table methods can be chained together, so that we can build, filter _and_ order a Table. For example:

----
# get a table with the nametags of all the fixed animals, ordered by species
animals-table.build-column("label", nametag).filter(is-fixed).order-by("species", true)
----

This code takes the `animals-table`, and builds a new column.
According to our Contracts Page, `.build-column` produces a new
Table, and that’s the Table whose `.filter` method we use. That
method produces _yet another Table_, and we call that Table’s
`order-by` method. The Table that comes back from that is our final
result.

////
Suggestion: use different color markers to draw nested boxes
around each part of the expression, showing where each Table came
from.
////

It can be difficult to read code that has lots of method calls
chained together, so we can add a line-break before each “.” to
make it more readable. Here’s the exact same code, written with
each method on its own line:

----
# get a table with the nametags of all the fixed animals, order by species
animals-table
  .build-column("label", nametag)
  .filter(is-fixed)
  .order-by("species", true)
----

[.lesson-point]
Order matters: Build, Filter, Order.

Suppose we want to build a column and then use it to filter our
table. If we use the methods in the wrong order (trying to filter
by a column that doesn’t exist yet), we might wind up crashing
the program. Even worse, the program might work, but produce
results that are incorrect!

[.lesson-point]
When chaining methods, it’s important to build first, then filter, and then order.

How well do you know your table methods? Complete
@worksheet-link{workbook-pages/chaining-methods.adoc} and
@worksheet-link{workbook-pages/chaining-methods-order-matters.adoc}
in your Student Workbook to find out.

////
Have students discuss their answers.
////


== Closing (Time 5 minutes)

As our analysis gets more complex, method chaining is a great way
to keep the code simple. But complex analysis also has more room
for mistakes, so it’s critical to think carefully when we use it.
