= Piecewise Functions 2 

@lesson-description{Students apply their knowledge of piecewise functions to write a function to move the player in their game.}


[.left-header,cols="20a,80a", stripes=none]
|===
@prereqs-stds{PiecewiseFunctions}
|Lesson Goals
|Students will be able to:

* Apply previous knowledge of @vocab{piecewise function}s to a new problem situation.

|Student-Facing Lesson Goals
|
* I can write a function using conditionals to move my player.

|Key Points for the Facilitator
|
* Encourage students to challenge themselves when creating update-player by completing one of the extension activities.
* The update-player function is one of the main places where students can set their game apart and make it theirs.  Encourage exploration and experimentation!
* Adding comments to code - if you have to ask a student "What are you trying to do there?", then they probably need more comments!  

|Prerequisites
|
* Students should be familiar with Circles of Evaluation.
* Students should be familiar with the Design Recipe for conditionals.

|Materials
|
ifeval::["{proglang}" == "wescheme"]
* Lesson slides template (@link{https://docs.google.com/presentation/d/1u0Zg-ErvH4ICRewgDeT42hnWngMrxPM1QwGSm8_FW-E/edit?usp=sharing, Google Slides})
endif::[]
ifeval::["{proglang}" == "pyret"]
* Lesson slides template (@link{https://drive.google.com/open?id=1p5gSt0ic3HC8oSltN_wSfqochw-eGUa_W2Ag56mEfpw, Google Slides})
endif::[]

* Design Recipe: update-player (@worksheet-link{workbook-pages/PiecewiseFunctions2-EX1.adoc, PDF})
|===


== Get Ready:

Students should have their computer, workbook, contracts page, and pencil.

== Launch: (5 min)

Connect The Dots - Students think of what they did in the previous lesson on piecewise functions specifically, then generalize those concepts. (Example: We wrote a function that gave different responses based on the input.)  Students then think of how those concepts might be applied to their game.  (What element of the game needs user input?) 
  

== Explore: (5 min)

Students open their *Game Project file* and look for where a @vocab{conditional} function would be necessary, then figure out what the contract represents.  

[.strategy-box]
.Strategies for English Language Learners
****
MLR 6 - Three Reads: Have students read through the problem statement three times, looking for different information.  What is the problem asking me?  What is the @vocab{contract} for this @vocab{function}?  What information do I need to create that function?
****

== Discuss: (10 min)

* *What is the contract for `update-player`?*
+
ifeval::["{proglang}" == "wescheme"]
_``update-player: Number String -> Number``_
endif::[]
ifeval::["{proglang}" == "pyret"]
_``update-player: Number, String -> Number``_
endif::[]
* *What does each part of the domain and range represent?*
+
_Domain: the Number is the y-coordinate of `PLAYER`, the String is the key that the user pressed; Range: the Number is the new y-coordinate of `PLAYER`_
* *What should happen mathematically to the y-coordinate of `PLAYER` when the user presses the "up" key?*
+
_It should increase, the program should add something to it_

@image{images/player-move.png, Player Movement, 400, align="center"}

== Practice: (15 min) 

Students complete @worksheet-link{workbook-pages/PiecewiseFunctions2-EX1.adoc, Design Recipe: update-player} with a partner, then type their code into their *Game Project file* and test.  

== Create/Apply: (15 min)

Students choose one or more features to make their game more unique. 

ifeval::["{proglang}" == "wescheme"]
Reminder: Use `;` to add comments to code! +
endif::[]
ifeval::["{proglang}" == "pyret"]
Reminder: Use `#` to add comments to code! +
endif::[]
Adding useful comments to code is an important part of programming. It lets us leave messages for other programmers, leave notes for ourselves, or "turn off" pieces of code that we don't want or need to @vocab{debug} later.

Some ideas for features:

* Warping - program one key to "warp" the player to a set location, such as the center of the screen
* Boundaries - change `update-player` such that `PLAYER` cannot move off the top or bottom of the screen 
* Wrapping - add code to `update-player` such that when `PLAYER` moves to the top of the screen, it reappears at the bottom, and vice versa
* Hiding - add a key that will make `PLAYER` seem to disappear, and reappear when the same key is pressed again
